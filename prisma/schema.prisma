
generator client {
  provider = "prisma-client-js"
  output   = "../src/generated/prisma"
}

datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}

model Food {
  id String @id @default(uuid())
  name String
  description String
  image String
  icon String?
  category FoodCategory @default(VEGETABLE)
  unit FoodUnit @default(PIECE)
  userId String? // Hacer opcional para ingredientes globales (admin)
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt
  
  // Relación con el usuario propietario
  user User? @relation(fields: [userId], references: [id], onDelete: Cascade)
  
  // Relación con preferencias de usuarios
  userPreferences UserFoodPreference[]
  // Relación con inventario de usuarios
  userInventory UserIngredientInventory[]
}

enum FoodCategory {
  VEGETABLE
  FRUIT
  MEAT
  DAIRY
  GRAIN
  LIQUID
  SPICE
  OTHER
}

enum FoodUnit {
  PIECE
  GRAM
  KILOGRAM
  LITER
  MILLILITER
  CUP
  TABLESPOON
  TEASPOON
  POUND
  OUNCE
}

model User {
  id String @id @default(uuid())
  email String @unique
  name String?
  password String?
  role UserRole @default(USER)
  image String?
  emailVerified DateTime?
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt
  
  // Relación con ingredientes propios
  foods Food[]
  
  // Relación con preferencias de alimentos
  foodPreferences UserFoodPreference[]
  
  // Relación con inventario de ingredientes
  ingredientInventory UserIngredientInventory[]
  
  // Relación con recetas generadas
  recipes Recipe[]
  
  // Relación con calendario de comidas
  mealCalendar MealCalendar[]
  
  // Relación con preferencias de usuario
  userPreferences UserPreferences?
  
  // Relación con sistema de amistades
  sentFriendRequests FriendRequest[] @relation("SentFriendRequests")
  receivedFriendRequests FriendRequest[] @relation("ReceivedFriendRequests")
  friendships1 Friendship[] @relation("User1Friendships")
  friendships2 Friendship[] @relation("User2Friendships")
  
  // Relación con eventos/juntadas
  createdEvents Event[] @relation("EventCreator")
  eventParticipants EventParticipant[]
  notifications Notification[]
  
  // Relación con sesiones de NextAuth
  accounts Account[]
  sessions Session[]
}

model UserFoodPreference {
  id String @id @default(uuid())
  userId String
  foodId String
  isAvailable Boolean @default(false)
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt
  
  user User @relation(fields: [userId], references: [id], onDelete: Cascade)
  food Food @relation(fields: [foodId], references: [id], onDelete: Cascade)
  
  @@unique([userId, foodId])
}

model Recipe {
  id String @id @default(uuid())
  title String
  description String
  ingredients String // JSON string de ingredientes seleccionados
  instructions String
  cookingTime Int? // en minutos
  difficulty String? // Fácil, Medio, Difícil
  servings Int? // número de porciones
  healthConditions String[] // Array de condiciones de salud para las que es ideal esta receta
  customHealthConditions String[] // Array de condiciones de salud personalizadas
  userId String
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt
  
  user User @relation(fields: [userId], references: [id], onDelete: Cascade)
  mealCalendar MealCalendar[]
  events Event[]
}

enum UserRole {
  USER
  ADMIN
}

// Modelos para NextAuth.js
model Account {
  id String @id @default(uuid())
  userId String
  type String
  provider String
  providerAccountId String
  refresh_token String? @db.Text
  access_token String? @db.Text
  expires_at Int?
  token_type String?
  scope String?
  id_token String? @db.Text
  session_state String?
  
  user User @relation(fields: [userId], references: [id], onDelete: Cascade)
  
  @@unique([provider, providerAccountId])
}

model Session {
  id String @id @default(uuid())
  sessionToken String @unique
  userId String
  expires DateTime
  
  user User @relation(fields: [userId], references: [id], onDelete: Cascade)
}

model VerificationToken {
  identifier String
  token String @unique
  expires DateTime
  
  @@unique([identifier, token])
}

// Modelo para inventario de ingredientes del usuario
model UserIngredientInventory {
  id String @id @default(uuid())
  userId String
  foodId String
  quantity Float
  unit FoodUnit
  expirationDate DateTime?
  notes String?
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt
  
  user User @relation(fields: [userId], references: [id], onDelete: Cascade)
  food Food @relation(fields: [foodId], references: [id], onDelete: Cascade)
  
  @@unique([userId, foodId])
}

// Modelo para calendario de comidas
model MealCalendar {
  id String @id @default(uuid())
  userId String
  date DateTime
  mealType MealType
  recipeId String?
  customMealName String?
  isPlanned Boolean @default(false)
  isCompleted Boolean @default(false)
  notes String?
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt
  
  user User @relation(fields: [userId], references: [id], onDelete: Cascade)
  recipe Recipe? @relation(fields: [recipeId], references: [id], onDelete: SetNull)
  
  @@unique([userId, date, mealType])
}

enum MealType {
  BREAKFAST
  LUNCH
  SNACK
  DINNER
}

// Modelo para preferencias del usuario
model UserPreferences {
  id String @id @default(uuid())
  userId String @unique
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt
  
  // Información de salud
  healthConditions String[] // Array de condiciones de salud
  customHealthConditions String[] // Condiciones personalizadas del usuario
  
  // Objetivos personales
  personalGoals String[] // Array de objetivos personales
  customPersonalGoals String[] // Objetivos personalizados del usuario
  
  // Preferencias de cocina
  cookingSkill String // "mucho", "mas_o_menos", "poco"
  cookingTime String // "mucho", "mas_o_menos", "poco"
  
  // Información demográfica
  servings Int // Número de personas para las que cocina
  country String? // País del usuario
  locationEnabled Boolean @default(false) // Si permite acceso a ubicación
  
  // Relación con el usuario
  user User @relation(fields: [userId], references: [id], onDelete: Cascade)
}

// Modelo para solicitudes de amistad
model FriendRequest {
  id String @id @default(uuid())
  senderId String
  receiverId String
  status FriendRequestStatus @default(PENDING)
  message String?
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt
  
  sender User @relation("SentFriendRequests", fields: [senderId], references: [id], onDelete: Cascade)
  receiver User @relation("ReceivedFriendRequests", fields: [receiverId], references: [id], onDelete: Cascade)
  
  @@unique([senderId, receiverId])
}

enum FriendRequestStatus {
  PENDING
  ACCEPTED
  DECLINED
}

// Modelo para amistades establecidas
model Friendship {
  id String @id @default(uuid())
  user1Id String
  user2Id String
  createdAt DateTime @default(now())
  
  user1 User @relation("User1Friendships", fields: [user1Id], references: [id], onDelete: Cascade)
  user2 User @relation("User2Friendships", fields: [user2Id], references: [id], onDelete: Cascade)
  
  @@unique([user1Id, user2Id])
}

// Modelo para eventos/juntadas
model Event {
  id String @id @default(uuid())
  title String
  description String?
  date DateTime
  mealType MealType
  location String?
  maxParticipants Int?
  isActive Boolean @default(true)
  creatorId String
  recipeId String? // Receta generada para el evento
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt
  
  creator User @relation("EventCreator", fields: [creatorId], references: [id], onDelete: Cascade)
  participants EventParticipant[]
  recipe Recipe? @relation(fields: [recipeId], references: [id], onDelete: SetNull)
}

// Modelo para participantes de eventos
model EventParticipant {
  id String @id @default(uuid())
  eventId String
  userId String
  status EventParticipantStatus @default(INVITED)
  joinedAt DateTime?
  createdAt DateTime @default(now())
  
  event Event @relation(fields: [eventId], references: [id], onDelete: Cascade)
  user User @relation(fields: [userId], references: [id], onDelete: Cascade)
  
  @@unique([eventId, userId])
}

enum EventParticipantStatus {
  INVITED
  ACCEPTED
  DECLINED
}

// Modelo para notificaciones
model Notification {
  id String @id @default(uuid())
  userId String
  type NotificationType
  title String
  message String
  isRead Boolean @default(false)
  relatedId String? // ID del elemento relacionado (evento, solicitud, etc.)
  createdAt DateTime @default(now())
  
  user User @relation(fields: [userId], references: [id], onDelete: Cascade)
}

enum NotificationType {
  FRIEND_REQUEST
  FRIEND_REQUEST_ACCEPTED
  EVENT_INVITATION
  EVENT_CANCELLED
  EVENT_RECIPE_GENERATED
}